// Generated by CoffeeScript 1.6.3
(function() {
  var _Player, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  this.SIGHT_UP = 0;

  this.SIGHT_RIGHT = 1;

  this.SIGHT_DOWN = 2;

  this.SIGHT_LEFT = 3;

  this.PSTATE_EXPLORE = 0;

  this.PSTATE_ATTACK = 1;

  this.PSTATE_FLEE = 2;

  this.MAX_HEALTH = 100;

  this.CRITICAL_HEALTH = 25;

  this.Player = _Player = (function(_super) {
    __extends(_Player, _super);

    function _Player() {
      _ref = _Player.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    _Player.prototype.init = function() {
      var dbuilder, i, u, _i, _j, _ref1, _ref2;
      this.image = 'images/soldier.png';
      this.load_image();
      dbuilder = new DecisionBuilder;
      this.decision = dbuilder.generate_tree();
      this.name = '';
      this.health = MAX_HEALTH;
      this.damage = 5;
      this.speed = 1;
      this.sight_radius = 1;
      this.score = 0;
      this.map = g.get_map();
      this.explored_tiles = new Array(this.map.width);
      for (i = _i = 0, _ref1 = this.map.width - 1; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
        this.explored_tiles[i] = new Array(this.map.height);
        for (u = _j = 0, _ref2 = this.map.height - 1; 0 <= _ref2 ? _j <= _ref2 : _j >= _ref2; u = 0 <= _ref2 ? ++_j : --_j) {
          this.explored_tiles[i][u] = false;
        }
      }
      this.state = PSTATE_EXPLORE;
      this.current_action = null;
      this.current_goal = null;
      this.current_path = null;
      this.seeable_objects = new Array;
      this.active_bonuses = new Array;
      return this.retreat_tile = null;
    };

    _Player.prototype.set_state = function(state) {
      return this.state = state;
    };

    _Player.prototype.get_next_move = function() {
      var step;
      step = this.current_path.splice(0, 1);
      if (step.length > 0) {
        this.explored_tiles[step[0].posx][step[0].posy] = true;
        return [step[0].posx - this.posx, step[0].posy - this.posy];
      } else {
        this.current_path = null;
      }
      return [0, 0];
    };

    _Player.prototype.find_path_to_target = function(obj) {
      var p, path;
      p = new Path;
      path = p.find_path(this, obj);
      return path;
    };

    _Player.prototype.process_bonuses = function() {
      var i, new_bonuses, o, _i, _ref1;
      new_bonuses = new Array;
      if (this.active_bonuses.length > 0) {
        for (i = _i = 0, _ref1 = this.active_bonuses.length - 1; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
          o = this.active_bonuses[i];
          o.timeout -= 1;
          if (o.timeout === 0) {
            o.do_timeout(this);
          } else {
            new_bonuses.push(o);
          }
        }
      }
      return this.active_bonuses = new_bonuses;
    };

    _Player.prototype.is_acting = function() {
      return this.current_action !== null;
    };

    _Player.prototype.has_goal = function() {
      return this.current_goal !== null;
    };

    _Player.prototype.get_goal = function() {
      return 1;
    };

    _Player.prototype.set_goal = function(obj) {
      this.current_path = null;
      return this.current_goal = obj;
    };

    _Player.prototype.clear_current_goal = function() {
      this.current_goal = null;
      return this.current_path = null;
    };

    _Player.prototype.can_see_object = function() {
      var i, o, tiles, _i, _ref1;
      this.seeable_objects = new Array;
      tiles = this.map.get_adjacent_tiles(this.posx, this.posy);
      for (i = _i = 0, _ref1 = tiles.length - 1; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
        o = tiles[i].get_object();
        if (o !== null) {
          this.seeable_objects.push(o);
        }
      }
      return this.seeable_objects.length !== 0;
    };

    _Player.prototype.is_object_consumable = function() {
      var obj;
      obj = this.seeable_objects[0];
      console.log('Is consumable');
      console.log(obj instanceof PowerUp);
      return obj instanceof PowerUp;
    };

    _Player.prototype.is_object_player = function() {
      var obj;
      obj = this.seeable_objects[0];
      console.log('Is Player');
      console.log(obj instanceof Player);
      return obj instanceof Player;
    };

    _Player.prototype.is_fighting = function() {
      return this.state === PSTATE_ATTACK;
    };

    _Player.prototype.can_attack = function() {
      if (this.health > CRITICAL_HEALTH) {
        return true;
      }
      return false;
    };

    _Player.prototype.is_health_good = function() {
      if (this.health > CRITICAL_HEALTH) {
        return true;
      }
      return false;
    };

    _Player.prototype.attack = function() {
      var obj;
      this.state = PSTATE_ATTACK;
      obj = this.seeable_objects[0];
      console.log(this.name + ": attacking");
      console.log("Inflicting damage: " + this.damage);
      obj.get_damaged(this.damage);
      if (obj.health <= 0) {
        this.score += 1;
        return g.player_death(obj);
      }
    };

    _Player.prototype.get_damaged = function(dmg) {
      console.log(this.name + ": got injured for " + dmg);
      return this.health -= dmg;
    };

    _Player.prototype.can_flee = function() {
      var map, t, tiles, _i, _len;
      map = g.get_map();
      tiles = map.get_adjacent_tiles(this.posx, this.posy);
      console.log("Can flee?");
      console.log(tiles);
      for (_i = 0, _len = tiles.length; _i < _len; _i++) {
        t = tiles[_i];
        if (t.is_walkable()) {
          this.retreat_tile = t;
          console.log("Retreat tile: ", this.retreat_tile);
          return true;
        }
      }
      return false;
    };

    _Player.prototype.flee = function() {
      var nx, ny;
      this.state = PSTATE_FLEE;
      console.log(this.name, "Fleeing");
      nx = this.retreat_tile.posx - this.posx;
      ny = this.retreat_tile.posy - this.posy;
      return this.move(nx, ny);
    };

    _Player.prototype.pick_random_tile = function() {
      var good, x, y;
      good = false;
      while (!good) {
        x = get_random_int(0, this.map.width - 1);
        y = get_random_int(0, this.map.height - 1);
        if (this.map.is_tile_walkable(x, y)) {
          return [x, y];
        }
      }
    };

    _Player.prototype.search_player = function() {
      var nx, ny, tile, x, y, _ref1, _ref2;
      this.state = PSTATE_EXPLORE;
      if (this.current_path === null) {
        _ref1 = this.pick_random_tile(), x = _ref1[0], y = _ref1[1];
        tile = this.map.tiles[x][y];
        this.current_path = this.find_path_to_target(tile);
        if (!this.current_path) {
          throw "No feasible path found, cannot move further :(";
        }
      }
      _ref2 = this.get_next_move(), nx = _ref2[0], ny = _ref2[1];
      return this.move(nx, ny);
    };

    _Player.prototype.consume_object = function() {
      var obj;
      obj = this.seeable_objects.splice(0, 1)[0];
      obj.pre_consume(this);
      obj.consume(this);
      obj.post_consume(this);
      return this.move(obj.posx - this.posx, obj.posy - this.posy);
    };

    _Player.prototype.do_action = function() {
      var err, i, node, _i, _ref1, _results;
      this.process_bonuses();
      _results = [];
      for (i = _i = 1, _ref1 = this.speed; 1 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 1 <= _ref1 ? ++_i : --_i) {
        node = this.decision.make_decision(this);
        if (node !== null) {
          this.current_action = node.action;
          try {
            _results.push(this[this.current_action]());
          } catch (_error) {
            err = _error;
            _results.push(console.error(err));
          }
        } else {
          _results.push(console.log("We have no action to take. Returned node is null"));
        }
      }
      return _results;
    };

    return _Player;

  })(this.MovableGameObject);

}).call(this);
